import { capitalizeFirstLetter } from './utils.js';

// Level type specific generators
import { generatePlatformerCode } from './levelTypes/platformer.js';
import { generateMazeCode } from './levelTypes/maze.js';
import { generateOpenWorldCode } from './levelTypes/openWorld.js';
import { generateTowerDefenseCode } from './levelTypes/towerDefense.js';
import { generateObstacleCourseCode } from './levelTypes/obstacleCourse.js';
import { generateRacingCode } from './levelTypes/racing.js';
import { generateCustomLevelCode } from './levelTypes/custom.js';

/**
 * Generates Lua code for level layout
 */
export function generateLevelCode(params) {
  const { levelType, size, includePlayerSpawns, includeCheckpoints } = params;
  
  let code = `-- ${levelType.charAt(0).toUpperCase() + levelType.slice(1)} Level Generator
-- Generated by Roblex Studio MCP Server - Level Designer
-- Level size: ${size}, Type: ${levelType}

local function Create${capitalizeFirstLetter(levelType)}Level()
    local level = Instance.new("Folder")
    level.Name = "${capitalizeFirstLetter(levelType)}Level"
    level.Parent = workspace

    -- Set up basic structure
    local structure = Instance.new("Folder")
    structure.Name = "Structure"
    structure.Parent = level
`;

  // Add level specific code based on level type
  switch (levelType) {
    case 'platformer':
      code += generatePlatformerCode(size);
      break;
    case 'maze':
      code += generateMazeCode(size);
      break;
    case 'open-world':
      code += generateOpenWorldCode(size);
      break;
    case 'tower-defense':
      code += generateTowerDefenseCode(size);
      break;
    case 'obstacle-course':
      code += generateObstacleCourseCode(size);
      break;
    case 'racing':
      code += generateRacingCode(size);
      break;
    default:
      code += generateCustomLevelCode(size);
  }

  // Add player spawn points if requested
  if (includePlayerSpawns) {
    code += `
    -- Set up player spawn points
    local spawns = Instance.new("Folder")
    spawns.Name = "PlayerSpawns"
    spawns.Parent = level
    
    local spawn1 = Instance.new("SpawnLocation")
    spawn1.Name = "SpawnLocation1"
    spawn1.Parent = spawns
    spawn1.CFrame = CFrame.new(0, 10, 0)
    spawn1.Anchored = true
    spawn1.CanCollide = false
    spawn1.Transparency = 1
`;
  }

  // Add checkpoints if requested
  if (includeCheckpoints) {
    code += `
    -- Set up checkpoints
    local checkpoints = Instance.new("Folder")
    checkpoints.Name = "Checkpoints"
    checkpoints.Parent = level
    
    local checkpoint1 = Instance.new("Part")
    checkpoint1.Name = "Checkpoint1"
    checkpoint1.Parent = checkpoints
    checkpoint1.CFrame = CFrame.new(25, 5, 25)
    checkpoint1.Size = Vector3.new(10, 1, 10)
    checkpoint1.Anchored = true
    checkpoint1.CanCollide = false
    checkpoint1.Transparency = 0.5
    checkpoint1.BrickColor = BrickColor.new("Bright green")
`;
  }

  // Complete the function and add execution code
  code += `
    return level
end

-- Create the level
local newLevel = Create${capitalizeFirstLetter(levelType)}Level()
`;

  return code;
}

/**
 * Generates setup instructions based on level parameters
 */
export function generateSetupInstructions(params) {
  const { levelType, size } = params;
  
  return `
## ${capitalizeFirstLetter(levelType)} Level Setup Instructions

1. Create a new ServerScript in ServerScriptService
2. Copy the provided code into the script
3. Run the game to generate the level
4. The level will be created as a Folder named "${capitalizeFirstLetter(levelType)}Level" in Workspace
5. You can modify the generated level structure after creation

### Structure Overview:
- Main level folder contains all elements
- Structure subfolder contains terrain and level geometry
- ${params.includePlayerSpawns ? '- PlayerSpawns subfolder contains spawn locations' : ''}
- ${params.includeCheckpoints ? '- Checkpoints subfolder contains checkpoint markers' : ''}

### Level Size: ${size}
This affects the overall scale of the generated level.
`;
}

/**
 * Generates best practices for the given level type
 */
export function generateBestPractices(levelType) {
  switch (levelType) {
    case 'platformer':
      return `
## Platformer Level Best Practices

1. Ensure platforms are spaced appropriately for jump distances
2. Add variety in platform heights and sizes
3. Include collectibles along challenging paths
4. Add visual indicators for jumps that are close to a player's maximum range
5. Consider adding moving platforms for advanced sections
6. Test jump sequences to ensure they're possible for the target player skill level
`;
    case 'maze':
      return `
## Maze Level Best Practices

1. Include landmarks to help players navigate
2. Consider adding a minimap for larger mazes
3. Balance the complexity - too simple is boring, too complex is frustrating
4. Add optional paths with rewards
5. Include visual variety to help with navigation
6. Test that the maze is solvable and there are no unintended shortcuts
`;
    case 'open-world':
      return `
## Open World Level Best Practices

1. Create distinct regions with unique visual identities
2. Add points of interest to encourage exploration
3. Consider level of detail management for performance
4. Include pathways that guide players to important locations
5. Add ambient environment elements for immersion
6. Balance open spaces with detailed areas
`;
    default:
      return `
## ${capitalizeFirstLetter(levelType)} Level Best Practices

1. Test gameplay flow to ensure a good player experience
2. Balance difficulty progression throughout the level
3. Consider performance implications of complex geometry
4. Add visual guides to help players understand the level
5. Include checkpoints at appropriate intervals
6. Ensure the level follows the theme consistently
`;
  }
}